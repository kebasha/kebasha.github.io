<html>
	<head>
	<title>大数据002</title>
	<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type' />

<link href='/images/fav.png' rel='shortcut icon'>
<link href='/stylesheets/style.css' rel='stylesheet' type='text/css' />
<link href='/stylesheets/syntax.css' rel='stylesheet' type='text/css' />
<link href='/stylesheets/responsive.css' rel='stylesheet' type='text/css' />
<link href="/stylesheets/nprogress.css" rel='stylesheet' type='text/css' />
<link href="/stylesheets/duoshuo.css" rel='stylesheet' type='text/css' />

<link href="/feed.xml" rel="alternate" type="application/rss+xml">

<script src='/javascripts/jquery.js' type='text/javascript'></script>
<script src='/javascripts/jquery.particleground.min.js' type='text/javascript'></script>
<script src='/javascripts/nprogress.js' type='text/javascript'></script>
<script src='/javascripts/theater.js' type='text/javascript'></script>

<script src='/javascripts/app.js' type='text/javascript'></script>
<script>var duoshuoQuery = {short_name:"jaylee"};</script>

	</head>
	<body>

		<header>
<a id="go-back-home" href="/"><img src="/images/scribble.png" alt="Home" width="53" height="59"></a>
<p>Jaylee</p>

<div id="blog-desc">
    Do have faith in what you're doing.
</div>

</header>


		<div id='container'>
			
			<div class="block nav">
    <ul>
    
        <li>
            <span class="line line-top"></span>
            <span class="line line-right"></span>
            <span class="line line-bottom"></span>
            <span class="line line-left"></span>
            <a target="_top" href="/about.html">About</a>
        </li>
    
        <li>
            <span class="line line-top"></span>
            <span class="line line-right"></span>
            <span class="line line-bottom"></span>
            <span class="line line-left"></span>
            <a target="_top" href="/">Blog</a>
        </li>
    
        <li>
            <span class="line line-top"></span>
            <span class="line line-right"></span>
            <span class="line line-bottom"></span>
            <span class="line line-left"></span>
            <a target="_top" href="/feed.xml">Feed</a>
        </li>
    
        <li>
            <span class="line line-top"></span>
            <span class="line line-right"></span>
            <span class="line line-bottom"></span>
            <span class="line line-left"></span>
            <a target="_blank" href="https://github.com/sjclijie">GitHub</a>
        </li>
        
    </ul>

</div>


			<section class="paging">
  
    <div class="left">
      <a href="/comprehensive-course-for-awk/">
        ‹
      </a>
    </div>
  
  
    <div class="right">
      <a href="/php-trait-details/">
        ›
      </a>
    </div>
  
</section>


			<div class="content">
				<section class='post'>
					<h1>
						PHP5.2自5.6新特性
						<div class='date'>26 Oct 2014</div>
					</h1>
					<p>截至目前( 2014.10 )，PHP的最新稳定版本是PHP5.6，但有差不多一半的用户仍然在使用已经不在维护的PHP5.2，其余的一半用户在使用PHP5.3 ( PHP5.3也于2014年9月停止支持 )。因为PHP那 “ 集百家之长 ”的蛋疼语法，加上社区氛围不太好，许多人对新版本，新特性并无兴趣。</p>

<hr>

<p><strong>本文会介绍自PHP5.2起，直到PHP5.6中增加的新特性。</strong></p>

<ul>
<li>PHP5.2以前：autoload, PDO和MySQLi, 类型约束</li>
<li>PHP5.2：JSON的支持</li>
<li>PHP5.3：弃用的功能，匿名函数，新增魔术方法，命名空间，延迟静态绑定，Heredoc和Nowdoc，const，三元运算符，Phar</li>
<li>PHP5.4：Short Open Tag，数组简写形式，Traits，内置web服务器，细节修改</li>
<li>PHP5.5：yield，list()可用于foreach循环，细节修改</li>
<li>PHP5.6：常量增强，可变函数参数，命名空间增强</li>
</ul>

<hr>

<blockquote>
<p>PHP5.2以前</p>

<p>2006年前（顺便介绍一下PHP5.2已经出现但是值得介绍的特性）</p>
</blockquote>

<p><strong><code>autoload</code></strong></p>

<p>大家应该都知道__autoload()函数，如果定义了该函数，那么当在代码中使用了一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">__autoload</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
        <span class="k">require_once</span> <span class="nv">$className</span><span class="o">.</span><span class="s2">&quot;.class.php&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nv">$foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>这样，在执行new操作的时候，会在当前目录下寻找Foo.class.php这个文件，并加载进来。</p>

<p>但该函数已经不建议使用，原因是一个项目中仅能有一个这样的__autoload()函数，因为PHP不允许函数重名。但当你用到一些类库的时候，难免会出现多个autoload函数的需要，于是spl_autoload_register()取而代之：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>    

    <span class="k">function</span> <span class="nf">autoloadModel</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
        <span class="nv">$filename</span> <span class="o">=</span> <span class="s2">&quot;models/&quot;</span><span class="o">.</span><span class="nv">$className</span><span class="o">.</span><span class="s2">&quot;.php&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">file_exists</span><span class="p">(</span><span class="nv">$filename</span><span class="p">)</span> <span class="p">){</span>
            <span class="k">require_once</span> <span class="nv">$filename</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="nf">autoloadController</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
        <span class="nv">$filename</span> <span class="o">=</span> <span class="s2">&quot;controller/&quot;</span><span class="o">.</span><span class="nv">$className</span><span class="o">.</span><span class="s2">&quot;.php&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">file_exists</span><span class="p">(</span><span class="nv">$filename</span><span class="p">)</span> <span class="p">){</span>
            <span class="k">require_once</span> <span class="nv">$filename</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nb">spl_autoload_register</span><span class="p">(</span><span class="s2">&quot;autoloadModel&quot;</span><span class="p">);</span>
    <span class="nb">spl_autoload_register</span><span class="p">(</span><span class="s2">&quot;autoloadController&quot;</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>spl_autoload_register()会将一个函数注册到autoload函数列表中，当出现未定义的类的时候，SPL会按照注册的顺序逐个调用被注册的autoload函数，这意味着你可以使用spl_autoload_register注册多个autoload函数。</p>

<p><strong><code>PDO和MySQLi</code></strong></p>

<p>PDO即PHP Data Object , PHP数据对象，这是PHP的新式数据库访问接口。</p>

<p>按照传统的风格，访问MySQL数据库应该是这个样子：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$conn</span> <span class="o">=</span> <span class="nb">mysql_connect</span><span class="p">(</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span><span class="s2">&quot;user&quot;</span><span class="p">,</span><span class="s2">&quot;passwd&quot;</span><span class="p">)</span> <span class="k">or</span> <span class="k">die</span><span class="p">(</span><span class="s2">&quot;Connection failed&quot;</span><span class="p">);</span>

    <span class="nb">mysql_select_db</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">);</span>

    <span class="nv">$type</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">];</span>

    <span class="nv">$sql</span> <span class="o">=</span> <span class="s2">&quot;select * from `table` where `type` = </span><span class="si">{</span><span class="nv">$type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span>

    <span class="nv">$result</span> <span class="o">=</span> <span class="nb">mysql_query</span><span class="p">(</span><span class="nv">$sql</span><span class="p">,</span> <span class="nv">$conn</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="nv">$row</span> <span class="o">=</span> <span class="nb">mysql_fetch_assoc</span><span class="p">(</span><span class="nv">$result</span><span class="p">)){</span>
        <span class="nb">var_dump</span><span class="p">(</span><span class="nv">$row</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nb">mysql_free_result</span><span class="p">(</span><span class="nv">$result</span><span class="p">);</span>

    <span class="nb">mysql_close</span><span class="p">(</span><span class="nv">$conn</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>为了能让代码实现与数据库无关，即同一段代码适用于多种数据库（例如以上代码仅适用于MySQL），PHP官方设计了PDO.</p>

<p>除此之外，PDO还提供了更多的功能，比如：</p>

<ul>
<li>面对对象风格接口</li>
<li>SQL预编译，占位符语法</li>
<li>更高的执行效率，作为官方推荐，有特别的性能优化</li>
<li>支持大部分SQL数据库，更换数据库无需改动代码</li>
</ul>

<p>上面的代码用PDO实现将会是这个样子：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">try</span> <span class="p">{</span>

        <span class="nv">$dsn</span> <span class="o">=</span> <span class="s2">&quot;mysql:host=localhost;dbname=test&quot;</span><span class="p">;</span>

        <span class="nv">$conn</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PDO</span><span class="p">(</span><span class="nv">$dsn</span><span class="p">,</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;passwd&quot;</span><span class="p">);</span>

        <span class="nv">$sql</span> <span class="o">=</span> <span class="s2">&quot;select * from user where type = :type &quot;</span><span class="p">;</span>

        <span class="nv">$stmt</span> <span class="o">=</span> <span class="nv">$conn</span><span class="o">-&gt;</span><span class="na">prepare</span><span class="p">(</span><span class="nv">$sql</span><span class="p">);</span>

        <span class="nv">$stmt</span><span class="o">-&gt;</span><span class="na">bindParams</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span><span class="nv">$_POST</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]);</span>

        <span class="nv">$stmt</span><span class="o">-&gt;</span><span class="na">execute</span><span class="p">();</span>

        <span class="nv">$stmt</span><span class="o">-&gt;</span><span class="na">fetchAll</span><span class="p">(</span><span class="nx">PDO</span><span class="o">::</span><span class="na">FETCH_ASSOC</span><span class="p">);</span>

    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">PDOException</span> <span class="nv">$e</span><span class="p">){</span>

        <span class="k">echo</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="na">getMessage</span><span class="p">();</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>PDO是官方推荐的，更为通用的数据库访问方式，如果你没有特殊的需求，那么最好学习和使用POD，但如果你需要使用MySQL所特有的高级功能，那么你可能需要尝试一下MySQLi，因为PDO为了能够同时在多种数据库上使用，不会包含那些MySQL独有的功能。</p>

<p><strong><code>类型约束</code></strong></p>

<p>通过类型约束可以限制参数的类型，不过这一机制并不完善，仅适用于对象，接口，callable，以及array，不适用于string和int，如果参数类型不匹配，则会产生一个fatal error.</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">test</span><span class="p">(</span><span class="nx">callable</span> <span class="nv">$callable</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$arr</span><span class="p">,</span> <span class="nx">MyClass</span> <span class="nv">$myclass</span><span class="p">){</span>
        <span class="c1">//...</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<hr>

<blockquote>
<p>PHP5.2</p>

<p>2006年 ~ 2011年</p>
</blockquote>

<p><strong><code>JSON支持</code></strong></p>

<p>包括json<em>encode(), json</em>decode()等函数，JSON算是在web领域非常实用的数据交换格式，可以被JS直接支持，JSON实际上JS语法的一部分。</p>

<p>JSON系列函数，可以将PHP中的数组结构与JSON字符串进行转换。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$arr</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span>
        <span class="s2">&quot;key&quot;</span>   <span class="o">=&gt;</span>  <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="s2">&quot;array&quot;</span> <span class="o">=&gt;</span>  <span class="k">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$json</span> <span class="o">=</span> <span class="nb">json_encode</span><span class="p">(</span><span class="nv">$arr</span><span class="p">);</span>

    <span class="k">echo</span> <span class="nv">$json</span><span class="p">;</span>

    <span class="nv">$object</span> <span class="o">=</span> <span class="nb">json_decode</span><span class="p">(</span><span class="nv">$json</span><span class="p">);</span>   

    <span class="nb">print_r</span><span class="p">(</span><span class="nv">$object</span><span class="p">);</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>输出：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    {&quot;key&quot;:&quot;value&quot;,&quot;array&quot;:[1,2,3,4]}

    stdClass Object
    (
        [key] =&gt; value
        [array] =&gt; Array
            (
                [0] =&gt; 1
                [1] =&gt; 2
                [2] =&gt; 3
                [3] =&gt; 4
            )
    )
</code></pre></div>
<p>值得注意的是，json_decode()默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设为true。同时json_encode()在php5.4的时候增加了一个<strong>JSON_UNESCAPED_UNICODE</strong>的常量，这样，如果键值对中包含中文就不会被编码成unicode字符了。</p>

<hr>

<blockquote>
<p>PHP5.3</p>

<p>2009年 ~ 2012年 PHP5.3算是一个非常大的更新 ，新增了大量的新特性，同时也做了一些不向下兼容的修改。</p>
</blockquote>

<p><strong><code>弃用的功能</code></strong></p>

<p>以下几个功能被弃用，若在配置文件中启用，则PHP在运行时会发出警告。</p>

<ul>
<li><code>Register Globals</code></li>
</ul>

<p>这是php.ini中的一个选项(register_globals)，开启后会将所有表单变量($_GET 和 $_POST）注册为全局变量。</p>

<p>看下面的例子：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">if</span> <span class="p">(</span> <span class="nx">isAuth</span><span class="p">()</span> <span class="p">){</span>
        <span class="nv">$autherize</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$autherize</span><span class="p">){</span>
        <span class="k">include</span><span class="p">(</span><span class="s2">&quot;page.php&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>这段代码在通过验证时，将$autherize设为true，然后根据$autherize的值来决定是否显示页面。</p>

<p>但由于没有事先把$authorize初始化为false，当register_globals打开时，可能访问/auth.php?authorize=1来定义该变量值，绕过身份验证。</p>

<p>该特征属于历史遗留原因，在PHP4.2中默认被关闭，在PHP5.4中被移除。</p>

<ul>
<li><code>Magic Quotes</code></li>
</ul>

<p>对应php.ini中的选项 magic<em>quotes</em>gpc，这个特征同样属于历史遗留原因，已经在PHP5.4移除。</p>

<p>该特征会对所有用户输入的 ‘ (单引号)，“ (双引号)，\(反斜线) 进行转义，和addslashes()作用完全一样，这看上去不错，但是PHP并不知道哪些输入会进SQL，哪些输入会进Shell，哪些输入会被显示为HTML，所以很多时候这种转义会引起混乱。</p>

<p>PHP一共有三个魔术引号指令：</p>

<p>magic_quotes_gpc：影响HTTP请求数据(GET, POST和COOKIE)，不能在运行时改变，在PHP中默认值为On。( 相关函数：get_magic_quotes_gpc() )</p>

<p>magic_quotes_runtime：如果打开的话，大部分从外部来源取得数据并返回的函数，包括从数据库和文件，所返回的数据都会被转义。该选项可在运行时改变，在PHP中默认值为Off。( 相关函数：get_magic_quotes_runtime()，set_magic_quotes_runtime() )</p>

<p>magic_quotes_sybase：如果打开的话，将会使用单引号对单引号进行转义而不是反斜线。此选项会完全覆盖magic_quote_gpc。( 获取该选项的值通过ini_get()函数 )</p>

<ul>
<li><code>Safe Model</code></li>
</ul>

<p>很多虚拟主机提供商使用Safe Mode 来隔离多个用户，但Safe Model存在诸多问题，例如有些扩展并不按照Safe Mode来进行控制。</p>

<p>PHP官方推荐使用操作系统的机制来进行权限隔离，让Web服务器以不同的用户权限来运行PHP解释器。</p>

<p><strong><code>匿名函数</code></strong></p>

<p>匿名函数也叫闭包(Closures)，经常被用来临时性的创建一个无名函数，用于回调函数等用途。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$func</span> <span class="o">=</span> <span class="k">function</span><span class="p">(){</span>
        <span class="nb">var_dump</span><span class="p">(</span><span class="nb">func_get_args</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nv">$func</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span><span class="s2">&quot;world&quot;</span><span class="p">);</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>以上代码定义了一个匿名函数，并赋值给了func。</p>

<p>可以看到定义匿名函数依然使用function关键字，只不过省略了函数名，直接是参数列表。</p>

<p>然后我们又调用了$func所储存的匿名函数。</p>

<p>匿名函数还可以通过use关键字来捕捉外部变量。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">ArrayPlus</span><span class="p">(</span><span class="nv">$array</span><span class="p">,</span> <span class="nv">$num</span><span class="p">){</span>

        <span class="nb">array_walk</span><span class="p">(</span><span class="nv">$array</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$v</span><span class="p">)</span> <span class="k">use</span><span class="p">(</span><span class="nv">$num</span><span class="p">){</span>
            <span class="nv">$v</span> <span class="o">*=</span> <span class="nv">$num</span><span class="p">;</span>
        <span class="p">});</span>

        <span class="k">return</span> <span class="nv">$array</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nb">var_dump</span><span class="p">(</span><span class="nx">ArrayPlus</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">));</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>上面的代码定义了一个ArrayPlus()函数（这不是匿名函数），它会将一个数组（$array）中的每一项，加上一个指定的数字（$num）。</p>

<p>在ArrayPlus()的实现中，我们使用了array_walk()函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。</p>

<p>在匿名函数的参数列表后，我们用use关键字将匿名函数外的$num捕捉到了函数内部，以便我们知道该加多少。</p>

<p><strong><code>魔术方法: __invoke(), __callStatic()</code></strong></p>

<p>PHP的面向对象体系中，提供了若干“魔术方法”，用于实现类似其它语言中的“重载”，如访问不存在的方法、属性时触发某个魔术方法。</p>

<p>随着匿名函数的加入，PHP引入了一个新的魔术方法__invoke()。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">__invoke</span><span class="p">(</span><span class="nv">$str</span><span class="p">){</span>
            <span class="k">echo</span> <span class="s2">&quot;A::__invoke:</span><span class="si">{</span><span class="nv">$str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>

    <span class="nv">$a</span><span class="p">(</span><span class="s2">&quot;jaylee.cc&quot;</span><span class="p">);</span>    <span class="c1">//A::__invoke:jaylee.cc</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>__callStatic()则会在调用一个不存在的静态方法时被调用。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">    </span><span class="cp">&lt;?php</span>

    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">__callStatic</span><span class="p">(</span><span class="nv">$methodName</span><span class="p">,</span> <span class="nv">$args</span><span class="p">){</span>
            <span class="nb">var_dump</span><span class="p">(</span><span class="nv">$methodName</span><span class="p">,</span> <span class="nv">$args</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">A</span><span class="o">::</span><span class="na">test</span><span class="p">(</span><span class="s2">&quot;aa&quot;</span><span class="p">,</span><span class="s2">&quot;bb&quot;</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong><code>命名空间</code></strong></p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="c1">// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。</span>
    <span class="c1">// 命名空间中可以包含任意代码，但只有类，函数，常量受命名空间的影响</span>

    <span class="k">namespace</span> <span class="nx">Jaylee\Test</span><span class="p">;</span>

    <span class="c1">// 该类的完整限定名是\Jaylee\Test\A，其中第一个反斜杠表示全局命名空间</span>
    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="k">public</span> <span class="k">function</span> <span class="nf">test</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="s2">&quot;namespace:&quot;</span><span class="o">.</span><span class="nx">__NAMESPACE__</span><span class="o">.</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="nx">__CLASS__</span><span class="o">.</span><span class="s2">&quot;&lt;br /&gt;&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 你还可以在命名空间中定义第二个命名空间，接下来的代码都位于\Other\Test2</span>
    <span class="k">namespace</span> <span class="nx">Other\Test2</span><span class="p">;</span>

    <span class="c1">// 实例化来自其它命名空间中的对象</span>
    <span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Jaylee\Test\A</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
        <span class="k">public</span> <span class="k">function</span> <span class="nf">test</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="s2">&quot;namespace:&quot;</span><span class="o">.</span><span class="nx">__NAMESPACE__</span><span class="o">.</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="nx">__CLASS__</span><span class="o">.</span><span class="s2">&quot;&lt;br /&gt;&quot;</span><span class="p">;</span>        
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">namespace</span> <span class="nx">Other</span><span class="p">;</span>

    <span class="c1">// 实例化来自子命名空间的对象        </span>
    <span class="nv">$b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test2\B</span><span class="p">;</span>

    <span class="nv">$b</span><span class="o">-&gt;</span><span class="na">test</span><span class="p">();</span>

    <span class="c1">// 导入来自其它命名空间的名称，并重命名</span>
    <span class="c1">// 注意只能导入类，不能用于函数和常量</span>
    <span class="k">use</span> <span class="nx">\Jaylee\Test\A</span> <span class="k">as</span> <span class="nx">ClassA</span><span class="p">;</span>

    <span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ClassA</span><span class="p">();</span>

    <span class="nv">$a</span><span class="o">-&gt;</span><span class="na">test</span><span class="p">();</span>    
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>更多有关命名空间的语法介绍请参见<a href="http://php.net/manual/zh/language.namespaces.rationale.php">官网</a>。</p>

<p>命名空间经常和autoload一起使用，用于自动加载类文件：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nb">spl_autoload_register</span><span class="p">(</span>
        <span class="k">function</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
            <span class="nb">spl_autoload</span><span class="p">(</span><span class="nb">str_replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="nv">$className</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>当你实例化一个类\Jaylee\Test\TestA的时候，这个类的完整限定名称会被传递给autoload函数，autoload函数将类名中的命名空间分隔符替换为反斜杠，并包含对应文件。</p>

<p>这样可以实现类定义文件分组存储，按需自动加载。</p>

<p><strong><code>延迟静态绑定</code></strong></p>

<p>PHP的的 OPP 机制，具有继承和类似虚函数的功能，例如如下的代码：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">callFoo</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">foo</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">foo</span><span class="p">(){</span>
            <span class="k">return</span> <span class="s2">&quot;A::foo()&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">B</span> <span class="k">extends</span> <span class="nx">A</span> <span class="p">{</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">foo</span><span class="p">(){</span>
            <span class="k">return</span> <span class="s2">&quot;B::foo()&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nv">$b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>

    <span class="nv">$b</span><span class="o">-&gt;</span><span class="na">callFoo</span><span class="p">();</span>      <span class="c1">//B::foo();</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>可以看到，当在A中使用了<code>$this-&gt;foo()</code>时，体现了“虚函数”的机制，实际调用的是B::foo()，然后如果将所有的函数都改为静态函数时：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

        <span class="k">static</span> <span class="k">public</span> <span class="k">function</span> <span class="nf">callFoo</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="nx">self</span><span class="o">::</span><span class="na">foo</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">public</span> <span class="k">function</span> <span class="nf">foo</span><span class="p">(){</span>
            <span class="k">return</span> <span class="s2">&quot;A::foo()&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">B</span> <span class="k">extends</span> <span class="nx">A</span> <span class="p">{</span>

        <span class="k">static</span> <span class="k">public</span> <span class="k">function</span> <span class="nf">foo</span><span class="p">(){</span>
            <span class="k">return</span> <span class="s2">&quot;B::foo()&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">B</span><span class="o">::</span><span class="na">callFoo</span><span class="p">();</span>   <span class="c1">//A::foo()</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>这时，输出的会是<code>A::foo()</code>，这是因为self的语义本来就是“当前类”，所有在PHP5.3给static关键赋予了一个新的功能：延迟静态绑定：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

        <span class="k">static</span> <span class="k">public</span> <span class="k">function</span> <span class="nf">callFoo</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="k">static</span><span class="o">::</span><span class="na">foo</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">//...</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>将self改为static之后，就会像预期一样输出<code>B::foo</code>了。</p>

<p><strong><code>Heredoc 和 Nowdoc</code></strong></p>

<p>PHP5.3对Heredoc以及Nowdoc进行了一些改进，它们都用于在PHP中嵌入大段的代码。</p>

<p>Heredoc的行为类似于一个双引号字符串：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="nv">$name</span> <span class="o">=</span> <span class="s2">&quot;Jaylee&quot;</span><span class="p">;</span>

<span class="k">echo</span> <span class="o">&lt;&lt;&lt;</span><span class="nx">TEXT</span>

<span class="nx">my</span> <span class="nx">name</span> <span class="nx">is</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$name</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="nx">TEXT</span><span class="p">;</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>Heredoc以三个尖括号开始，后面跟一个标识符（TEXT）,直到一个同样的定格标识符（不能缩进）结束。
就像双引号字符串一样，其中可以嵌入变量。</p>

<p>Heredoc还可以用于函数参数，以及类成员初始化：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="nb">var_dump</span><span class="p">(</span><span class="o">&lt;&lt;&lt;</span><span class="nx">EOD</span>
    <span class="nx">hello</span> <span class="nx">world</span>
<span class="nx">EOD</span>
<span class="p">);</span>


<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

    <span class="k">const</span> <span class="no">name</span> <span class="o">=</span> <span class="o">&lt;&lt;&lt;</span><span class="nx">EOD</span>
<span class="nx">hello</span> <span class="nx">world</span>
<span class="nx">EOD</span><span class="p">;</span>

    <span class="k">public</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="o">&lt;&lt;&lt;</span><span class="nx">EOD</span>
<span class="nx">hello</span> <span class="nx">world2</span>
<span class="nx">EOD</span><span class="p">;</span>

<span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>Nowdoc的行为像一个单引号字符串，不能在其中嵌入变量，和Heredoc唯一的区别就是，三个尖括号的标识符要用单引号引起来：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$name</span> <span class="o">=</span> <span class="s2">&quot;Jaylee&quot;</span><span class="p">;</span>

    <span class="k">echo</span> <span class="o">&lt;&lt;&lt;</span><span class="s1">&#39;EOD&#39;</span>

<span class="nx">my</span> <span class="nx">name</span> <span class="nx">is</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$name</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="nx">EOD</span><span class="p">;</span>

    <span class="c1">//输出：my name is &quot;{$name}&quot;</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong><code>用const定义常量</code></strong></p>

<p>php5.3起同时支持在全局命名空间和类中使用 const 定义常量。</p>

<p>旧式风格：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nb">define</span><span class="p">(</span><span class="s2">&quot;NAME&quot;</span><span class="p">,</span><span class="s2">&quot;jaylee&quot;</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>新式风格：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">const</span> <span class="no">NAME</span> <span class="o">=</span> <span class="s2">&quot;Jaylee&quot;</span><span class="p">;</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>const形式仅适用于常量，不适用于运行时才能求值的表达式。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">const</span> <span class="no">VALUE</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span> <span class="c1">//正确</span>

    <span class="k">const</span> <span class="no">VALUE</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="c1">//错误</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong><code>三元运算符的简写形式</code></strong></p>

<p>旧式风格：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">echo</span> <span class="nv">$a</span> <span class="o">?</span> <span class="nv">$a</span> <span class="o">:</span> <span class="s2">&quot;No VALUE&quot;</span><span class="p">;</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>可以简写成：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">echo</span> <span class="nv">$a</span> <span class="o">?</span> <span class="o">:</span> <span class="s2">&quot;No Value&quot;</span><span class="p">;</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>即如果省略三元运算符的第二个部分，会默认用第一个部分代替。</p>

<p><strong><code>Phar</code></strong></p>

<p>Phar即PHP Archive, 起初只是Pear中的一个库而已，后来在PHP5.3被重新编写成C扩展并内置到 PHP 中。
Phar用来将多个 .php 脚本打包(也可以打包其他文件)成一个 .phar 的压缩文件(通常是ZIP格式)。
目的在于模仿 Java 的 .jar, 不对，目的是为了让发布PHP应用程序更加方便。同时Phar还提供了数字签名验证等功能。</p>

<p>.phar 文件可以像 .php 文件一样被 PHP 引擎解释执行，同时你还可以写出这样的代码来包含 .phar 中的代码。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">require</span> <span class="s2">&quot;xxx.phar&quot;</span><span class="p">;</span>
    <span class="k">require</span> <span class="s2">&quot;phar://xxx.phar/aa/bb.php&quot;</span><span class="p">;</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>更多信息请参见<a href="http://www.php.net/manual/zh/phar.using.intro.php">官网</a>;</p>

<hr>

<blockquote>
<p>PHP5.4</p>

<p>2012 ~ 2013</p>
</blockquote>

<p><strong><code>Short Open Tag</code></strong></p>

<p>Short Open Tag 自PHP5.4起总是可用。</p>

<p>在这里集中讲一下有关 PHP 起止标签的问题。即：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="c1">//code</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>通常就是上面的形式，除此之外还有一种简写形式：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?</span> <span class="cm">/*  code  */</span> <span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>还可以把</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?</span> <span class="k">echo</span> <span class="nv">$foo</span><span class="p">;</span><span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>简写成：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?</span><span class="o">=</span><span class="nv">$foo</span><span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>这种简写形式被称为 Short Open Tag, 在 PHP5.3 起被默认开启，在 PHP5.4 起总是可用。
使用这种简写形式在 HTML 中嵌入 PHP 变量将会非常方便。</p>

<p>对于纯 PHP 文件(如类实现文件), PHP 官方建议顶格写起始标记，同时 <code>省略</code> 结束标记。
这样可以确保整个 PHP 文件都是 PHP 代码，没有任何输出，否则当你包含该文件后，设置 Header 和 Cookie 时会遇到一些麻烦（Header 和 Cookie 必须在输出任何内容之前被发送）。</p>

<p><strong><code>数组简写形式</code></strong></p>

<p>这是非常方便的一项特征！</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="c1">//原来数组的写法</span>
    <span class="nv">$arr</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s2">&quot;key&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;value2&quot;</span><span class="p">);</span>

    <span class="c1">//简写形式</span>
    <span class="nv">$arr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;key&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;value2&quot;</span><span class="p">];</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong><code>Traits</code></strong></p>

<p>所谓Traits就是“构件”，是用来替代继承的一种机制。PHP中无法进行多重继承，但一个类可以包含多个Traits.</p>

<p>详细内部请看<a href="/php-trait-details/">这里</a>还有<a href="/php-using-the-trait-implements-the-singleton-pattern/">这里</a></p>

<p><strong><code>内置 Web 服务器</code></strong></p>

<p>PHP从5.4开始内置一个轻量级的Web服务器，不支持并发，定位是用于开发和调试环境。</p>

<p>在开发环境使用它的确非常方便。</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">php -S localhost:8000
</code></pre></div>
<p>这样就在当前目录建立起了一个Web服务器，你可以通过 <a href="http://localhost:8000/">http://localhost:8000/</a> 来访问。</p>

<p>其中localhost是监听的ip，8000是监听的端口，可以自行修改。</p>

<p>很多应用中，都会进行URL重写，所以PHP提供了一个设置路由脚本的功能:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">php -S localhost:8000 index.php
</code></pre></div>
<p>这样一来，所有的请求都会由index.php来处理。</p>

<p><strong><code>细节修改</code></strong></p>

<p><strong>PHP5.4 新增了动态访问静态方法的方式：</strong></p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$func</span> <span class="o">=</span> <span class="s2">&quot;Foo&quot;</span><span class="p">;</span>

    <span class="nx">A</span><span class="o">::</span><span class="p">{</span><span class="nv">$func</span><span class="p">}();</span>   <span class="c1">// 相当于 A::Foo();</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong>新增在实例化时访问类成员的特征：</strong></p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="p">(</span><span class="k">new</span> <span class="nx">MyClass</span><span class="p">())</span><span class="o">-&gt;</span><span class="na">foo</span><span class="p">();</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong>新增支持对函数返回数组的成员访问解析(这种写法在之前版本是会报错的)：</strong></p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nb">var_dump</span><span class="p">(</span> <span class="nx">func</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>      <span class="c1">//如果func返回一个数据，这里直接取第0项元素</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<hr>

<blockquote>
<p>PHP5.5</p>

<p>2013起</p>
</blockquote>

<p><strong><code>yield关键字</code></strong></p>

<p>yield关键字用于当函数需要返回一个迭代器的时候，逐个返回值。</p>

<p>该函数返回一个迭代器对象。</p>

<p><strong><code>list()用于foreach</code></strong></p>

<p>该特性可以在foreach中解析嵌套的数组：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$arr</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s2">&quot;c&quot;</span><span class="p">]</span>
    <span class="p">];</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$arr</span> <span class="k">as</span> <span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$c</span><span class="p">)){</span>
        <span class="k">echo</span> <span class="nv">$a</span><span class="o">.</span><span class="s2">&quot;==&quot;</span><span class="o">.</span><span class="nv">$b</span><span class="o">.</span><span class="s2">&quot;==&quot;</span><span class="o">.</span><span class="nv">$c</span><span class="o">.</span><span class="nx">PHP_EOL</span><span class="p">;</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>结果：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    1==2==3
    a==b==c
</code></pre></div>
<p><strong><code>其它细节修改</code></strong></p>

<ul>
<li><p>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQLi, 参见前文。</p></li>
<li><p>不再支持Windows XP.</p></li>
<li><p>可用 MyClass::class 取到一个类的完整限定名(包括命名空间)。</p></li>
<li><p>empty() 支持表达式作为参数。</p></li>
<li><p>try-catch 结构新增 finally 块。</p></li>
</ul>

<hr>

<blockquote>
<p>PHP5.6</p>

<p>2014年8月</p>
</blockquote>

<p><strong><code>常量表达式</code></strong></p>

<p>在常量、属性声明和函数参数默认值声明时，以前版本只允许常量值，PHP5.6开始允许使用包含数字、字符串字面值和常量的标量表达式。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">const</span> <span class="no">ONE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="no">TWO</span> <span class="o">=</span> <span class="nx">ONE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>

        <span class="k">const</span> <span class="no">THREE</span> <span class="o">=</span> <span class="nx">TWO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">const</span> <span class="no">ONE_THIRD</span> <span class="o">=</span> <span class="nx">ONE</span> <span class="o">/</span> <span class="nx">self</span><span class="o">::</span><span class="na">THREE</span><span class="p">;</span>

        <span class="k">const</span> <span class="no">SENTENCE</span> <span class="o">=</span> <span class="s1">&#39;The value of &#39;</span><span class="o">.</span><span class="nx">self</span><span class="o">::</span><span class="na">THREE</span><span class="o">.</span><span class="s1">&#39; is 3&#39;</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">f</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">=</span> <span class="nx">ONE</span> <span class="o">+</span> <span class="nx">self</span><span class="o">::</span><span class="na">THREE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nv">$a</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">echo</span> <span class="p">(</span><span class="k">new</span> <span class="nx">C</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">f</span><span class="p">();</span>  <span class="c1">// 4</span>

    <span class="k">echo</span> <span class="nx">C</span><span class="o">::</span><span class="na">SENTENCE</span><span class="p">;</span>   <span class="c1">//The value of 3 is 3</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong><code>可变参数函数</code></strong></p>

<p>可变函数的实现，不再依赖<code>func_get_args()</code>函数，现在可以通过新增的操作符<code>...</code>更简洁地实现。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$req</span><span class="p">,</span> <span class="nv">$opt</span> <span class="o">=</span> <span class="k">null</span><span class="p">,</span> <span class="o">...</span><span class="nv">$params</span><span class="p">){</span>

        <span class="nb">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\$</span><span class="s2">req: %d; </span><span class="se">\$</span><span class="s2">opt: %d; number of params: %d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nv">$req</span><span class="p">,</span> <span class="nv">$opt</span><span class="p">,</span> <span class="nb">count</span><span class="p">(</span><span class="nv">$params</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="nx">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>以上输出：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">    $req: 1; $opt: 0; number of params: 0</span>
<span class="x">    $req: 1; $opt: 2; number of params: 0</span>
<span class="x">    $req: 1; $opt: 2; number of params: 1</span>
<span class="x">    $req: 1; $opt: 2; number of params: 2</span>
<span class="x">    $req: 1; $opt: 2; number of params: 3</span>
</code></pre></div>
<p><strong><code>参数解包功能</code></strong></p>

<p>在调用函数时，通过<code>...</code>操作符可以把数组或者可遍历对象解包到参数列表，这和Ruby等语言中的扩张(splat)操作符类似。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">add</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$c</span><span class="p">){</span>
        <span class="k">return</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="o">+</span> <span class="nv">$c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nv">$operators</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

    <span class="k">echo</span> <span class="nx">add</span><span class="p">(</span><span class="o">...</span><span class="nv">$operators</span><span class="p">);</span>    <span class="c1">//6</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong><code>导入函数和常量</code></strong></p>

<p>use 操作符开始支持函数和常量的导入。 <code>use function</code> 和 <code>use const</code> 结构的用法的示例：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">namespace</span> <span class="nx">cc\jaylee</span> <span class="p">{</span>

        <span class="k">const</span> <span class="no">FOO</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>

        <span class="k">function</span> <span class="nf">f</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="nx">__FUNCTION__</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">namespace</span> <span class="p">{</span>

        <span class="k">use</span> <span class="k">const</span> <span class="no">cc\jaylee\FOO</span><span class="p">;</span>
        <span class="k">use</span> <span class="k">function</span> <span class="nf">cc\jaylee\f</span><span class="p">;</span>

        <span class="k">echo</span> <span class="nx">FOO</span><span class="p">;</span>   <span class="nx">\\</span> <span class="mi">11</span>

        <span class="nx">f</span><span class="p">();</span>        <span class="nx">\\</span> <span class="nx">cc\jaylee\f</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong><code>phpdbg</code></strong></p>

<p>PHP自带了一个交互式调试器phpdbg，它是一个SAPI模块，更多信息参考<a href="http://phpdbg.com/docs"> phpdbg 文档</a>。</p>

<p><strong><code>php://input可以被复用</code></strong></p>

<p><code>php://input</code> 开始支持多次打开和读取，这给处理POST数据的模块的内存占用带来了极大的改善。</p>

<p><strong><code>大文件上传支持</code></strong></p>

<p>可以上传超过2G的大文件。</p>

<p><strong><code>GMP支持操作符重载</code></strong></p>

<p><strong><code>新增gost-crypto哈希算法</code></strong></p>

<p><strong><code>SSL/TLS改进</code></strong></p>

				</section>
			</div>

			
				<!-- 多说评论框 start -->
<div class="block ds-thread" data-title="PHP5.2自5.6新特性" data-url="http://www.jaylee.cc/php5-2-since-new-in-5-6/"></div>
<!-- 多说评论框 end -->
			

		</div>

		<script>

            jQuery(document).ready(function($) {

                App.mapKeySupport();

                App.initNProgress();

                App.initDuoshuo();

                App.initTheater();
            });

		</script>

	</body>

	<div id="particles">
    <canvas class="pg-canvas"></canvas>
</div>
<script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?93757bc26a1b57b9c6a7771db256d254";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();

    $(function(){

        var $body = $("body");

        $("#particles").css({
                "width":$body.width(), 
                "height":$body.height()
            }).particleground({
                lineColor: '#e0e0e0',
                dotColor: '#EFEFEF',
                lineColor: '#EFEFEF',   
                minSpeedX :0.5,
                maxSpeedX :1,
                minSpeedY : 0.5,
                maxSpeedY :1
            });
    });
</script>
<footer>
  <span class="muted">© Jaylee. All Rights Reserved.</span><br>
  <a href="http://github.com/chloerei/scribble" class="muted">built with Jekyll using Scribble theme</a>
  <br>
  <br>
  <!--img src="/images/scribble2.png" alt="scribble" /-->
</footer>


</html>
