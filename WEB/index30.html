<html>    <head>    <title>简单的线程池实现</title>    <meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'><meta content='text/html; charset=utf-8' http-equiv='content-type' /><link href='/styles/github.css' rel='stylesheet' type='text/css' /><script src='/javascripts/highlight.pack.js' type='text/javascript'></script><link href='/images/fav.png' rel='shortcut icon'><link href='/stylesheets/style.css' rel='stylesheet' type='text/css' /><link href='/stylesheets/syntax.css' rel='stylesheet' type='text/css' /><link href='/stylesheets/responsive.css' rel='stylesheet' type='text/css' /><link href="/stylesheets/nprogress.css" rel='stylesheet' type='text/css' /><link href="/stylesheets/duoshuo.css" rel='stylesheet' type='text/css' /><link href="/feed.xml" rel="alternate" type="application/rss+xml"><script src='/javascripts/jquery.js' type='text/javascript'></script><script src='/javascripts/jquery.particleground.min.js' type='text/javascript'></script><script src='/javascripts/nprogress.js' type='text/javascript'></script><script src='/javascripts/theater.js' type='text/javascript'></script><script src='/javascripts/app.js' type='text/javascript'></script><script>    hljs.initHighlightingOnLoad();    var duoshuoQuery = {short_name:"kbasha"};</script>    </head>    <body>        <header><div id="blog-desc">    If you want do, then do.</div></header><div id="main">    <div id="left">    <a id="head-pic" class="go-back-home" href="/"><img src="../images/kbasha.jpg" alt="Home" width="100" height="100"></a>    <p>克巴沙</p>        <ul id="titles" class="titles">                    </ul>    </div>    <div id="right">    <a id="scaner-pic" class="go-back-home" href="/"><img src="../images/kbasha_id.jpg" alt="Home" width="172" height="172"></a>    <p>关注公众号</p>            </div>        <div id='container'>                        <div class="block nav">    <ul>            <li>            <span class="line line-top"></span>            <span class="line line-right"></span>            <span class="line line-bottom"></span>            <span class="line line-left"></span>            <a target="_top" href="/about.html">About</a>        </li>            <li>            <span class="line line-top"></span>            <span class="line line-right"></span>            <span class="line line-bottom"></span>            <span class="line line-left"></span>            <a target="_top" href="/">Blog</a>        </li>        <li>            <span class="line line-top"></span>            <span class="line line-right"></span>            <span class="line line-bottom"></span>            <span class="line line-left"></span>            <a target="_blank" href="https://github.com/kebasha">GitHub</a>        </li>            </ul></div>            <section class="paging">      <div class="left">      <a href="index29.html">        ‹      </a>    </div>      <div class="right">      <a href="index31.html">        ›      </a>    </div>  </section><div class="content">    <section class='post'>        <h1>            简单的线程池实现            <div class='date'>2016-04-01 22:53:24</div>        </h1>      <blockquote><p style="text-indent:2em;">为了节省系统在多线程并发时不断创建和销毁线程所带来的额外开销，就需要引入线程池。线程池的基本功能就是进行线程的复用。当系统接受一个提交的任务，需要一个线程时，并不急着立即去创建线程，而是先去线程池查找是否有空余的线程，若有，则直接使用线程池中的线程工作，若没有，再却创建新的线程。等任务完成后，也不简单地销毁线程，而是将线程放入线程池的空闲队列，等待下次使用。</p><p style="text-indent:2em;">这样，在线程频繁调度的场合，可以节约不少系统开销。下例中，给出一个最为简单的线程池实现，该实现不是一个完善的线程池，但已经使用最简单的代码实现了一个基本线程池的核心功能。</p><pre><code class="java">public class ThreadPool {    private static ThreadPool instance = null;    //空闲的线程队列    private List&lt;PThread&gt; idleThreads;    //已有的线程总数    private int threadCounter;    private boolean isShutDown = false;    private ThreadPool(){       this.idleThreads = new Vector(5);       threadCounter = 0;    }    public int getCreatedThreadsCount(){       return threadCounter;    }    //取得线程池的实例    public synchronized static ThreadPool getInstance(){       if(instance == null){           instance = new ThreadPool();       }       return instance;    }    //将线程放入池中    protected synchronized void repool(PThread repoolingThread){       if(!isShutDown){           idleThreads.add(repoolingThread);       }else{           repoolingThread.shutDown();       }    }    //停止线程池中所有线程    public synchronized void shutdown(){       isShutDown = true;       for(int threadIndex = 0; threadIndex < idleThreads.size(); threadIndex++){           PThread idleThread = (PThread)idleThreads.get(threadIndex);           idleThread.shutDown();       }    }    //执行任务    public synchronized void start(Runnable target){       PThread thread = null;       //如果有空闲线程，则直接使用       if(idleThreads.size() > 0){           int lastIndex = idleThreads.size() - 1;           thread = (PThread)idleThreads.get(lastIndex);           idleThreads.remove(lastIndex);           //立即执行这个任务           thread.setTarget(target);       }else{           threadCounter++;           //创建新线程           thread = new PThread(target, "PThread #" + threadCounter, this);           //启动这个线程           thread.start();       }    }}</code></pre><blockquote><p style="text-indent:2em;">要使用上述线程池，需要一个永不退出的线程与之配合。PThread就是这样一个线程。它的线程主体部分是一个无限循环，该线程在手动关闭前永不结束，并一直等待新的任务达到。</p></blockquote><pre><code class="java">public class PThread extends Thread {    //线程池    private ThreadPool pool;    //任务    private Runnable target;    private boolean isShutDown = false;    private boolean isIdle = false;    public PThread(Runnable target, String name, ThreadPool pool){       super(name);       this.pool = pool;       this.target = target;    }    public Runnable getTarget(){       return target;    }    public boolean isIdle(){       return isIdle;    }    @Override    public void run() {       //只要没有关闭，则一直不结束该线程       while(!isShutDown){           isIdle = false;           if(target != null){              //运行任务              target.run();           }           //任务结束了到闲置状态           isIdle = true;           try {              //该任务结束后，不关闭线程，而是放入线程池空闲队列              pool.repool(this);              synchronized (this) {                  //线程空闲，等待新的任务到来                  wait();              }           } catch (Exception e) {              // TODO: handle exception           }           isIdle = false;       }    }    public synchronized void setTarget(Runnable newTarget){       target = newTarget;       //设置了任务之后，通知run方法，开始执行这个任务       notifyAll();    }    //关闭线程    public synchronized void shutDown(){       isShutDown = true;       notifyAll();    }}/*使用：首先定义一个线程类，作为任务对象：*/public class MyThread implements Runnable {    protected String name;    public MyThread(){    }    public MyThread(String name){       this.name = name;    }    public void run() {       try {           Thread.sleep(100);       } catch (Exception e) {           e.printStackTrace();       }    }}/*不使用线程池调度任务：*/for(int i=0; i&lt;1000; i++){   new Thread(new MyThread("testNoPool"+Integer.toString(i))).start();}/*使用线程池：*/for(int i=0; i&lt;1000; i++){   ThreadPool.getInstance().start(          new MyThread("testThreadPool"+Integer.toString(i)));}</code></pre>                </section>            </div>                    </div></div>        <script>            jQuery(document).ready(function($) {                App.mapKeySupport();                App.initNProgress();                App.initDuoshuo();                App.initTheater();            });        </script>    </body>    <div id="particles">    <canvas class="pg-canvas"></canvas></div><script type="text/javascript">    var _hmt = _hmt || [];    (function() {      var hm = document.createElement("script");      hm.src = "//hm.baidu.com/hm.js?93757bc26a1b57b9c6a7771db256d254";      var s = document.getElementsByTagName("script")[0];       s.parentNode.insertBefore(hm, s);    })();    $(function(){        var $body = $("body");        $("#particles").css({                "width":$body.width(),                 "height":$body.height()            }).particleground({                lineColor: '#e0e0e0',                dotColor: '#EFEFEF',                lineColor: '#EFEFEF',                   minSpeedX :0.5,                maxSpeedX :1,                minSpeedY : 0.5,                maxSpeedY :1            });    });</script><footer>  <span class="muted">© kbasha. All Rights Reserved.</span>  <br>  <br>  <!--img src="/images/scribble2.png" alt="scribble" /--></footer></html>